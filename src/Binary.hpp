#ifndef __BINARY_HPP__
#define __BINARY_HPP__

#include "type_conversion.hpp"
#include "Buffer.hpp"

namespace pni{
    namespace utils{
        template<typename NATIVETYPE> class BinaryType;
        template<typename NATIVETYPE> BinaryType<NATIVETYPE> 
            operator+(const BinaryType<NATIVETYPE> &a,const
                    BinaryType<NATIVETYPE> &b);
        template<typename NATIVETYPE> BinaryType<NATIVETYPE>
            operator-(const BinaryType<NATIVETYPE> &a,
                      const BinaryType<NATIVETYPE> &b);
        template<typename NATIVETYPE> BinaryType<NATIVETYPE>
            operator*(const BinaryType<NATIVETYPE> &a,
                      const BinaryType<NATIVETYPE> &b);
        template<typename NATIVETYPE> BinaryType<NATIVETYPE>
            operator/(const BinaryType<NATIVETYPE> &a,
                      const BinaryType<NATIVETYPE> &b);



        //! \ingroup  type_classes
        //! \brief Binary data type

        //! This class represents a binary data type. Usually one would 
        //! represent binary data by a typedef to an unsigne char type. 
        //! However, this has an inconvienance: the unsigned char and the
        //! typdef for binary are indistinguishable. Thus, this binary 
        //! type cannot be used in connection with typemaps. 
        //! The binary type itself serves only one perpose: read and write
        //! uniterpreted binary data to and from a stream or file. 
        //! The type generated by this template is binary compatible 
        //! with the NATIVETYPE template parameter provided during 
        //! instantiation. However, on compiler level it is a 
        //! different type und thus can be distinguished by the template
        //! engine from NATIVETYPE. 
        //! 
        //! Since binary data is considered entirely uninterpreted 
        //! all arithmetic operations have been stripped from this template.
        //! The only thing one can do is to read and write data as binary. 
        //! This is not a limitation but thats exactly what this type 
        //! was made for.
        template<typename NATIVETYPE> class BinaryType{
            private:
                NATIVETYPE _value;

                //we do not want to allow any numerical calculation on 
                //binary data.
                friend BinaryType<NATIVETYPE> operator+ <> 
                    (const BinaryType<NATIVETYPE> &a,const
                     BinaryType<NATIVETYPE> &b);
                friend BinaryType<NATIVETYPE> operator- <> 
                    (const BinaryType<NATIVETYPE> &a,
                     const BinaryType<NATIVETYPE> &b);
                friend BinaryType<NATIVETYPE> operator* <>
                    (const BinaryType<NATIVETYPE> &a,
                     const BinaryType<NATIVETYPE> &b);
                friend BinaryType<NATIVETYPE> operator/ <> 
                    (const BinaryType<NATIVETYPE> &a,
                     const BinaryType<NATIVETYPE> &b);

                const BinaryType<NATIVETYPE> & operator+=(const
                        BinaryType<NATIVETYPE> &b);
                const BinaryType<NATIVETYPE> & operator-=(const
                        BinaryType<NATIVETYPE> &b);
                const BinaryType<NATIVETYPE> & operator*=(const
                        BinaryType<NATIVETYPE> &b);
                const BinaryType<NATIVETYPE> & operator/=(const
                        BinaryType<NATIVETYPE> &b);
            public:
                //! native type that is used for binary data
                typedef NATIVETYPE binary_type;
                //constructors
                explicit BinaryType();
                BinaryType(NATIVETYPE value);
                BinaryType(const BinaryType<NATIVETYPE> &o);
                ~BinaryType();

                //assignment operators
                BinaryType<NATIVETYPE> &operator=(const BinaryType<NATIVETYPE> &o);
                BinaryType<NATIVETYPE> &operator=(const NATIVETYPE &value);

                operator NATIVETYPE() const{
                    return _value;
                }


        };
        
        //=========implementation of constructors===============================
        //implementation of the default constructor
        template<typename NATIVETYPE> BinaryType<NATIVETYPE>::BinaryType(){
        }

        template<typename NATIVETYPE> BinaryType<NATIVETYPE>::BinaryType(NATIVETYPE
                value)
        {
            _value = value;
        }

        template<typename NATIVETYPE> BinaryType<NATIVETYPE>::BinaryType(const
                BinaryType<NATIVETYPE> &o)
        {
            _value = o._value;
        }

        template<typename NATIVETYPE> BinaryType<NATIVETYPE>::~BinaryType(){

        }

        //===============implementation of the assignment operators=============
        template<typename NATIVETYPE> BinaryType<NATIVETYPE> &
            BinaryType<NATIVETYPE>::operator=(const BinaryType<NATIVETYPE> &o)
        {
            if(this == &o) return &this;

            _value = o._value;

            return *this;
        }

        template<typename NATIVETYPE> BinaryType<NATIVETYPE> &
            BinaryType<NATIVETYPE>::operator=(const NATIVETYPE &value)
        {
            _value = value;
            return *this;
        }

        template<typename NATIVETYPE>
        std::ostream &operator<<(std::ostream &os,const BinaryType<NATIVETYPE> &o)
        {
            NATIVETYPE b = o;
            os<<b;
            return os;
        }

        template<typename NATIVETYPE>
        std::istream &operator>>(std::istream &is,BinaryType<NATIVETYPE> &o){
            NATIVETYPE b;
            is>>b;
            o = b;
            return is;
        }

    }
}


#endif
