#ifndef __BINARY_HPP__
#define __BINARY_HPP__


namespace pni{
namespace utils{

    /*! \ingroup  type_classes
    \brief Binary data type

    This class represents a binary data type. Usually one would represent 
    binary data by a typedef to an unsigne char type.  However, this has 
    an inconvienance: the unsigned char and the typdef for binary are 
    indistinguishable. Thus, this binary type cannot be used in 
    connection with typemaps.  The binary type itself serves only one 
    perpose: read and write uniterpreted binary data to and from a 
    stream or file.  The type generated by this template is binary 
    compatible with the NATIVETYPE template parameter provided during 
    instantiation. However, on compiler level it is a different type 
    and thus can be distinguished by the template engine from NATIVETYPE. 
    
    Since binary data is considered entirely uninterpreted all 
    arithmetic operations have been stripped from this template.  The 
    only thing one can do is to read and write data as binary.  This 
    is not a limitation but thats exactly what this type was made for.
    */
    template<typename NTYPE> class BinaryType{
        private:
            NTYPE _value; //!< data value

            //! unary addition operator - deleted
            const BinaryType<NTYPE> & 
                operator+=(const BinaryType<NTYPE> &b) = delete;
            //! unary subtraction operator - delete
            const BinaryType<NTYPE> & 
                operator-=(const BinaryType<NTYPE> &b) = delete;
            //! unary multiplication operator
            const BinaryType<NTYPE> & 
                operator*=(const BinaryType<NTYPE> &b) = delete;
            //! unary division operator - delete
            const BinaryType<NTYPE> & 
                operator/=(const BinaryType<NTYPE> &b) = delete;
        public:
            //=================public data types===============================
            //! native type that is used for binary data
            typedef NTYPE binary_type;

            //=============constructors and destructor=========================
            //! default constructor
            explicit BinaryType();

            //-----------------------------------------------------------------
            //! constructor
            BinaryType(const NTYPE &value);

            //-----------------------------------------------------------------
            //! copy constructor
            BinaryType(const BinaryType<NTYPE> &o);

            //-----------------------------------------------------------------
            //! destructor
            ~BinaryType();

            //=================assignment operators============================
            //! copy assignment operators
            BinaryType<NTYPE> &operator=(const BinaryType<NTYPE> &o);

            //-----------------------------------------------------------------
            //! assignment from a single value
            BinaryType<NTYPE> &operator=(const NTYPE &value);

            //-----------------------------------------------------------------
            //! conversion operator
            operator NTYPE() const
            {
                return _value;
            }

    };


    template<typename NTYPE> BinaryType<NTYPE> 
        operator+(const BinaryType<NTYPE> &a,const BinaryType<NTYPE> &b)
        = delete;

    template<typename NTYPE> BinaryType<NTYPE>
        operator-(const BinaryType<NTYPE> &a,const BinaryType<NTYPE> &b)
        =delete;

    template<typename NTYPE> BinaryType<NTYPE>
        operator*(const BinaryType<NTYPE> &a,const BinaryType<NTYPE> &b)
        =delete;

    template<typename NTYPE> BinaryType<NTYPE>
        operator/(const BinaryType<NTYPE> &a,const BinaryType<NTYPE> &b)
        =delete;

    
    //=========implementation of constructors==================================
    //implementation of the default constructor
    template<typename NTYPE> BinaryType<NTYPE>::BinaryType()
    { }

    //-------------------------------------------------------------------------
    template<typename NTYPE> 
        BinaryType<NTYPE>::BinaryType(const NTYPE &value):
        _value(value)
    { }

    //-------------------------------------------------------------------------
    template<typename NTYPE> 
        BinaryType<NTYPE>::BinaryType(const BinaryType<NTYPE> &o):
        _value(o._value)
    { }

    //-------------------------------------------------------------------------
    template<typename NTYPE> BinaryType<NTYPE>::~BinaryType()
    { }

    //===============implementation of the assignment operators================
    template<typename NTYPE> BinaryType<NTYPE> &
        BinaryType<NTYPE>::operator=(const BinaryType<NTYPE> &o)
    {
        if(this == &o) return *this;

        _value = o._value;

        return *this;
    }

    //-------------------------------------------------------------------------
    template<typename NTYPE> BinaryType<NTYPE> &
        BinaryType<NTYPE>::operator=(const NTYPE &value)
    {
        _value = value;
        return *this;
    }

    //-------------------------------------------------------------------------
    template<typename NTYPE>
    std::ostream &operator<<(std::ostream &os,const BinaryType<NTYPE> &o)
    {
        NTYPE b = o;
        os<<b;
        return os;
    }

    //-------------------------------------------------------------------------
    template<typename NTYPE>
    std::istream &operator>>(std::istream &is,BinaryType<NTYPE> &o){
        NTYPE b;
        is>>b;
        o = b;
        return is;
    }

//end of namespace
}
}
#endif
