/*! \defgroup buffer_classes Data buffer types

The buffer templates provide types which store data in a contiguous region of
memory. They are intended as a replacement for raw pointers. Indeed one can think 
of a buffer template as a guard object around a raw pointer. The templates make 
a pointer a first class object reducing thus the danger of memory leaks as the 
memory allocated by a buffer is freed once the object is destroyed. 
All buffer templates share the same interface as shown below
\code
template<typename T,...> class Buffer
    public:
    //==========the following public types must be available===================
    typedef ... value_type;
    typedef ... buffer_type;
    typedef ... shared_ptr;
    typedef ... unique_ptr;
    typedef ... iterator;
    typedef ... const_iterator;
    //================public members===========================================
    static const TypeID type_id    = TypeIDMap<T>::type_id;

    //================constructors=============================================
    Buffer(); //must posses a default constructor

    //==================assignment operators===================================
    buffer_type &operator=(const buffer_type &b); //must provide a copy constructor


    //=================methods for data access=================================
    
    const value_type *ptr() const;   //get access to the internal storage

   
    //linear access - must not throw
    value_type &operator[](size_t i); 
    //linear access - must not throw
    value_type operator[](size_t i) const; 
    //linear access - throws IndexError if i exceeds the buffer size
    value_type &at(size_t i);
    //linear access - throws IndexError if i exceeds the buffer size
    value_type at(size_t i) const;
    //linear access - throws IndexError if i exceeds the buffer size
    void insert(size_t pos,const value_type &v);

    size_t size() const;       //return number of elements of type T

    //===================iterator related methods==============================
    iterator begin();
    iterator end();
    const_iterator begin() const;
    const_iterator end() const;

};
\endcode
A buffer template behaves like a STL container. Thus it can be used with all STL
functions defined in the C++ standard. However, unlike STL containers the buffer
templates provided access to the allocated memory region by their ptr() method. 
For this reason the region of memory referred to by a buffer template must be
contiguous.
*/
