/*! \defgroup multidim_array_classes Multidimensional array classes
These classes are responsible for storing and manipulating data in memory. 




\section Arrays

Arrays are types representing multidimensional arrays of data. Basically each
array consists of an object managing the multidimensional shape of the array and
a storage object holding the data. Array data can be accessed in two ways
    \li linearly where subsequent elements are traversed one after the other and
    each element has a linear index
    \li index-access where each element is determined by its multidimensional
    index.

Linear access to the data is granted via the method already known from the
Buffer interface. Index access is provided by special methods. For
multidimensional data access the result of a selection can be 
The following implicit interface must be granted for arrays
\code
template<typename T> class Array
{
    public:
    //==================public types===========================================
    typedef ... value_type;     // type of the elements stored in the array
    typedef ... shared_ptr;     // a shared pointer to the array
    typedef ... unique_ptr;     // a unique pointer to the array
    typedef ... iterator;       // iterator 
    typedef ... const_iterator; // constant iterator
    typedef ... array_type;     // array type
    typedef ... storage_type;   // type of the storage 
    typedef ... view_type;      // type of the view 
    //================public members===========================================
    static const TypeID type_id    = TypeIDMap<value_type>::type_id;

    //==================constructor and destructor=============================
    Array(); //need default constructor
    Array(const Array &a); //copy constructor
    template<typename ATYPE> Array(const ATYPE &a); //other array type

    //=======================assignment operator===============================
    array_type &operator=(const array_type &a); //copy assignment operator

    //======================methods for multiindex data access=================
   
    //if all arguments are integer numbers return a reference to the 
    template<typename ...ITYPES>
    typename ArrayViewSelector<array_type,ITYPES...>::reftype 
    operator()(ITYPES ...indices);

    template<typename ...ITYPES>
    typename ArrayViewSelector<array_type,ITYPES...>::viewtype 
    operator()(ITYPES ...indices);

    template<template<typename ...> class CTYPE,typename ...OTS> 
    typename ArrayViewSelector<array_type,typename CTYPE::value_type>::reftype
    operator()(const CTYPE<OTS...> &index);

    template<template<typename ...> class CTYPE,typename ...OTS> 
    typename ArrayViewSelector<array_type,typename CTYPE::value_type>::viewtype
    operator()(const CTYPE<OTS...> &index) const;

    //================methods for linear data access===========================

    //operators for linear data access - these operators are assumed not to
    //throw any exception
    value_type &operator[](size_t i); 
    value_type operator[](size_t i) const; 

    //methods for linear data access with index checking - these methods are
    //assumed to throw IndexError if the index exceeds the size of the array
    value_type &at(size_t i);
    value_type at(size_t i) const;
    void insert(size_t pos,const value_type &v);

    //get a const. reference to the storage object
    const storage_type &storage() const; 

    //===============methods for array inquery==================================
    size_t size() const;       //return number of elements of type T
    size_t rank() const;       //number of dimensions 

    //return a container of type CTYPE with the number of elements along each
    //dimension
    template<typename CTYPE> shape() const; 

    //===================iterator related methods==============================
    iterator begin();
    iterator end();
    const_iterator begin() const;
    const_iterator end() const;
};
\endcode

The following types provided by this library implement the above Array-interface
<table >
    <tr>
        <th> Type template </th>
        <th> purpose </th>
        <th> remarks </th>
    </tr>
    <tr> 
        <td> DynamicArray </td> 
        <td> Array type for runtime allocation </td> 
        <td>
        Use this template if an array is required whose shape can be adjusted at
        runtime.
        </td>
    </tr>
    <tr> 
        <td> StaticArray </td> 
        <td> fixed size at compile time </td> 
        <td>
        This template should be used for arrays whose size is already known at
        compile time. The resulting type is very memory efficient. It basically
        requires only space for the data stored in it.
        </td>
    </tr>
    <tr>
        <td> ArrayView </td>
        <td> provides a particular view on an array type </td>
        <td>
        This type is used to provide a view on only a part of one of the
        previous array types. It owns no memory but holds a reference to the
        original array from which it was drawn. 
        </td>
    </tr>
</table>
*/
