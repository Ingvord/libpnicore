/*! \defgroup data_classes Data classes
These classes are responsible for storing and manipulating data in memory. 

\section Buffers

Buffers are the fundamental types for holding data. The \c Buffer here describes
rather a concept than a concrete type. Every type that might be used as a buffer
in the code has to satisfy the following implicit interface
\code
template<typename T,...> class Buffer
    public:
    //==========the following public types must be available===================
    typedef ... value_type;
    typedef ... buffer_type;
    typedef ... shared_ptr;
    typedef ... unique_ptr;
    typedef ... iterator;
    typedef ... const_iterator;
    //================public members===========================================
    static const TypeID type_id    = TypeIDMap<T>::type_id;

    //================constructors=============================================
    Buffer(); //must posses a default constructor

    //==================assignment operators===================================
    buffer_type &operator=(const buffer_type &b); //must provide a copy constructor


    //=================methods for data access=================================
    
    const value_type *ptr() const;   //get access to the internal storage

    
    value_type &operator[](size_t i); 
    value_type operator[](size_t i) const; 
    value_type &at(size_t i);
    value_type at(size_t i) const;
    void insert(size_t pos,const value_type &v);

    size_t size() const;       //return number of elements of type T

    //===================iterator related methods==============================
    iterator begin();
    iterator end();
    const_iterator begin() const;
    const_iterator end() const;

};
\endcode
The iterators provided by the Buffer types must be random access iterators in
the sense of STL. Thus, all standard STL algorithms can be used with the Buffer
types. 

\section shape_section Shape objects and index mapping

Shape objects are an important part of the code as they map multidimensional
array indices to a linear memory offset and vice verse. It is clear that several
implementations are needed to satisfy different needs of users. 
A type that shall be used as shape must implement the following implicit
interface

\code
class Shape
{
    public:
    //=======================constructors and destructor=======================
    Shape(); //default constructible

    //========================assignment operators=============================
    Shape &operator=(const Shape &s); //copy assignable 

    //=====================index and offset related methods====================

    //compute offset from an argument list
    template<typename ...ITYPES> size_t offset(ITYPES ...indices);

    //compute offset from a container type
    template<CTYPE> size_t offset(const CTYPE &v);

    //compute the multidimensional index for a particular offset value
    //and return the result in an arbitrary container type
    template<CTYPE> CTYPE index(size_t offset);

    //compute the multidimensional index for a particular offset value and store
    //the result in an already existing container
    template<CTYPE> void index(size_t offset,CTYPE &c);

    //=======================accessing shape parameters========================
    size_t rank() const; number of dimensions
    size_t size() const; number of elements covered by the shape

    //return number of elements along each dimension of the shape
    template<CONT> CONT shape() const;

    size 


};
\endcode


\section Arrays

Arrays are types representing multidimensional arrays of data. Basically each
array consists of an object managing the multidimensional shape of the array and
a storage object holding the data. Array data can be accessed in two ways
    \li linearly where subsequent elements are traversed one after the other and
    each element has a linear index
    \li index-access where each element is determined by its multidimensional
    index.

Linear access to the data is granted via the method already known from the
Buffer interface. Index access is provided by special methods. For
multidimensional data access the result of a selection can be 
The following implicit interface must be granted for arrays
\code
template<typename T> class Array
{
    public:
    //==================public types===========================================
    typedef ... value_type;     // type of the elements stored in the array
    typedef ... shared_ptr;     // a shared pointer to the array
    typedef ... unique_ptr;     // a unique pointer to the array
    typedef ... iterator;       // iterator 
    typedef ... const_iterator; // constant iterator
    typedef ... array_type;     // array type
    typedef ... storage_type;   // type of the storage 
    typedef ... view_type;      // type of the view 
    //================public members===========================================
    static const TypeID type_id    = TypeIDMap<value_type>::type_id;

    //==================constructor and destructor=============================
    Array(); //need default constructor
    Array(const Array &a); //copy constructor
    template<typename ATYPE> Array(const ATYPE &a); //other array type

    //=======================assignment operator===============================
    array_type &operator=(const array_type &a); //copy assignment operator

    //======================methods for multiindex data access=================
   
    //if all arguments are integer numbers return a reference to the 
    template<typename ...ITYPES>
    typename ArrayViewSelector<array_type,ITYPES...>::reftype 
    operator()(ITYPES ...indices);

    template<typename ...ITYPES>
    typename ArrayViewSelector<array_type,ITYPES...>::viewtype 
    operator()(ITYPES ...indices);

    template<template<typename ...> class CTYPE,typename ...OTS> 
    typename ArrayViewSelector<array_type,typename CTYPE::value_type>::reftype
    operator()(const CTYPE<OTS...> &index);

    template<template<typename ...> class CTYPE,typename ...OTS> 
    typename ArrayViewSelector<array_type,typename CTYPE::value_type>::viewtype
    operator()(const CTYPE<OTS...> &index) const;

    //================methods for linear data access===========================

    //operators for linear data access - these operators are assumed not to
    //throw any exception
    value_type &operator[](size_t i); 
    value_type operator[](size_t i) const; 

    //methods for linear data access with index checking - these methods are
    //assumed to throw IndexError if the index exceeds the size of the array
    value_type &at(size_t i);
    value_type at(size_t i) const;
    void insert(size_t pos,const value_type &v);

    //get a const. reference to the storage object
    const storage_type &storage() const; 

    //===============methods for array inquery==================================
    size_t size() const;       //return number of elements of type T
    size_t rank() const;       //number of dimensions 

    //return a container of type CTYPE with the number of elements along each
    //dimension
    template<typename CTYPE> shape() const; 

    //===================iterator related methods==============================
    iterator begin();
    iterator end();
    const_iterator begin() const;
    const_iterator end() const;
};
\endcode

The following types provided by this library implement the above Array-interface
<table >
    <tr>
        <th> Type template </th>
        <th> purpose </th>
        <th> remarks </th>
    </tr>
    <tr> 
        <td> DynamicArray </td> 
        <td> Array type for runtime allocation </td> 
        <td>
        Use this template if an array is required whose shape can be adjusted at
        runtime.
        </td>
    </tr>
    <tr> 
        <td> StaticArray </td> 
        <td> fixed size at compile time </td> 
        <td>
        This template should be used for arrays whose size is already known at
        compile time. The resulting type is very memory efficient. It basically
        requires only space for the data stored in it.
        </td>
    </tr>
    <tr>
        <td> ArrayView </td>
        <td> provides a particular view on an array type </td>
        <td>
        This type is used to provide a view on only a part of one of the
        previous array types. It owns no memory but holds a reference to the
        original array from which it was drawn. 
        </td>
    </tr>
</table>
*/
