/*! \defgroup index_mapping_classes Index Mapping classes

This page is only important for developers who want to contribute to \c
libpnicore. It provides information about index mapping and the selection
mechanism used for multidimensional arrays.

\section index_mapping_fundamentals Fundamentals - what is it all about?

In a multidimensional array each element is addressed by a multidimensional
index. However, the data is usually stored in a linear (one-dimensional)
container. Index mapping is the process where the multidimensional index is
transformed into a corresponding linear index which identifies the proper
element in the linear container. It is clear that this mapping must be unique
in a sense that each multidimensional index refers to exactly one linear index
in the contains. Thus, an inverse function exists transforming a linear index to
a multidimensional one. 
The problem can easily visualized by the following example: consider an array of
rank 2 and shape (5x5). There are two possibilities how the indices (i,j) of the
array can be mapped on a linear index:

\image html column_major_ordering.svg "Column major ordering - first index varies fastest" 
\image html row_major_ordering.svg "Row major ordering - last index varies fastest"

The first case - column major ordering - is what Fortran is doing while the
later situation is the C-way of mapping (i,j) to a linear index.
Both mapping serve the same result but have a different layout of the data in
the linear storage array.

\section row_major_ordering Index mapping for C-style arrys

\c libpninx uses the C-mapping by default. 

\section index_map Index map interface

Shape objects are an important part of the code as they map multidimensional
array indices to a linear memory offset and vice verse. It is clear that several
implementations are needed to satisfy different needs of users. 
A type that shall be used as shape must implement the following implicit
interface

\code
class IndexMap
{
    public:
    //=======================constructors and destructor=======================
    IndexMap(); //default constructible

    //========================assignment operators=============================
    Shape &operator=(const Shape &s); //copy assignable 

    //=====================index and offset related methods====================

    //compute offset from an argument list
    template<typename ...ITYPES> size_t offset(ITYPES ...indices);

    //compute offset from a container type
    template<CTYPE> size_t offset(const CTYPE &v);

    //compute the multidimensional index for a particular offset value
    //and return the result in an arbitrary container type
    template<CTYPE> CTYPE index(size_t offset);

    //compute the multidimensional index for a particular offset value and store
    //the result in an already existing container
    template<CTYPE> void index(size_t offset,CTYPE &c);

    //=======================accessing shape parameters========================
    //number of dimensions
    size_t rank() const; 
    //number of elements that can be addressed by this map
    size_t size() const; 

    //return number of elements along each dimension of the shape
    template<CONT> CONT shape() const;

};
\endcode

\section array_selection Selections in multidimensional arrays

*/
