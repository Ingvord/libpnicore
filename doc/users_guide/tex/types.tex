%%%documentation on data types

\newcommand{\dtype}[1]{{\tt #1}}
\newcommand{\podt}[2]{\dtype{#1#2}}
\newcommand{\typeid}[1]{{\tt type\_id\_t::#1}}
\newcommand{\typeidmap}{{\tt type\_id\_map}}
\newcommand{\idtypemap}{{\tt id\_type\_map}}


%%%==================================================================================
\begin{table}[tb]
\centering
\begin{tabular}{l|l|p{0.36\linewidth}}
\hline
data type & type ID & description \\
\hline\hline
\podt{uint}{8}      & \typeid{UINT8}  & 8Bit unsinged integer           \\
\podt{int}{8}       & \typeid{INT8}   & 8Bit signed integer             \\
\podt{uint}{16}     & \typeid{UINT16} & 16Bit unsigned integer          \\
\podt{int}{16}      & \typeid{INT16}  & 16Bit signed integer            \\
\podt{uint}{32}     & \typeid{UINT32} & 32Bit unsigned integer          \\
\podt{int}{32}      & \typeid{INT32}  & 32Bit signed integer            \\
\podt{uint}{64}     & \typeid{UINT64} & 64Bit unsigned integer          \\
\podt{int}{64}      & \typeid{INT64}  & 64Bit signed integer            \\
\podt{float}{32}    & \typeid{FLOAT32} & 32Bit IEEE floating point type  \\
\podt{float}{64}    & \typeid{FLOAT64} & 64Bit IEEE floating point type  \\
\podt{float}{128}   & \typeid{FLOAT128} & 128Bit IEEE floating point type \\
\podt{complex}{32}  & \typeid{COMPLEX32} & 32Bit IEEE complex float type   \\
\podt{complex}{64}  & \typeid{COMPLEX64} &64Bit IEEE complex float type   \\
\podt{complex}{128} & \typeid{COMPLEX128} & 128Bit IEEE complex float type  \\
\dtype{string}      & \typeid{STRING} & string  type                    \\
\dtype{binary}      & \typeid{BINARY} & binary type                     \\
\hline
\end{tabular}
\caption{\small\label{tab:types:basic_types} An overview of the basic POD data
types provided by \libpnicore.}
\end{table}
%%%===================================================================================
\libpnicore\ provides a set of primitive data types, defined in {\tt
pni/core/types.hpp}, along with a set of utility functions
and data structures for type management. These types are ensured to
have the same size on every platform and architecture supported by the library
\footnote{The only exceptions are 128Bit floating point numbers which have a
    different size on some RISC architectures.}.
Table~\ref{tab:types:basic_types} shows an overview of all supported types as
defined in  {\tt pni/core/types.hpp}. Most of them are just {\tt typedef}s to
existing plain old data (POD) types. The complex types use the {\tt
std::complex} template provided by the C++ standard library. This is also true
for the {\tt string} type which is just a {\tt typedef} to {\tt std::string}. 
Basically one can identify three classes of primitive types
\begin{enumerate}
\item numeric types with all their arithmetic operations
\item string types (currently only one member)
\item and utility types like {\tt binary} and {\tt bool} (the latter one is used
from the C++ standard library).
\end{enumerate}

While most of these types are straight forward {\tt binary} requires a bit more
attention. {\tt binary} is an 8Bit sized type mainly introduced to carry 
uniterpreted binary data (usually for transfer purposes).  See
Section~\ref{section:using_binary} for details.

\section{Identifying types at runtime}
%%%============================================================================
\begin{table}[tb]
\centering
\begin{minipage}[t]{0.49\linewidth}
\centering
\begin{tabular}{l|p{0.48\linewidth}}
\hline
data type & {\tt type\_id\_t} value \\
\hline\hline
\podt{uint}{8}      & \typeid{UINT8}      \\
\podt{int}{8}       & \typeid{INT8}       \\
\podt{uint}{16}     & \typeid{UINT16}     \\
\podt{int}{16}      & \typeid{INT16}      \\
\podt{uint}{32}     & \typeid{UINT32}     \\
\podt{int}{32}      & \typeid{INT32}      \\
\podt{uint}{64}     & \typeid{UINT64}     \\
\podt{int}{64}      & \typeid{INT64}      \\
\podt{float}{32}    & \typeid{FLOAT32}    \\
\podt{float}{64}    & \typeid{FLOAT64}    \\
\podt{float}{128}   & \typeid{FLOAT128}   \\
\podt{complex}{32}  & \typeid{COMPLEX32}  \\
\podt{complex}{64}  & \typeid{COMPLEX64}  \\
\podt{complex}{128} & \typeid{COMPLEX128} \\
\dtype{string}      & \typeid{STRING}     \\
\dtype{binary}      & \typeid{BINARY}     \\
\hline
\end{tabular}
\caption{\small\label{tab:types:type_ids} \libpnicore s basic types and thier ID
values.}
\end{minipage}
\hfill
\begin{minipage}[t]{0.49\linewidth}
\centering
\begin{tabular}{l|p{0.48\linewidth}}
\hline
data type & string representation \\
\hline\hline
\podt{uint}{8}      &   {\tt "uint8"} , {\tt "ui8"} \\
\podt{int}{8}       &   {\tt "int8"} , {\tt "i8"}   \\
\podt{uint}{16}     &   {\tt "uint16"}, {\tt "ui16"}  \\
\podt{int}{16}      &   {\tt "int16"}, {\tt "i16"}   \\
\podt{uint}{32}     &   {\tt "uint32"}, {\tt "ui32"}   \\
\podt{int}{32}      &   {\tt "int32"}, {\tt "i32"}  \\
\podt{uint}{64}     &   {\tt "uint64"}, {\tt "ui64"}  \\
\podt{int}{64}      &   {\tt "int64"}, {\tt "i64"}  \\
\podt{float}{32}    &   {\tt "float32"}, {\tt "f32"}  \\
\podt{float}{64}    &   {\tt "float64"}, {\tt "f64"}  \\
\podt{float}{128}   &   {\tt "float128"}, {\tt "f128"}  \\
\podt{complex}{32}  &   {\tt "complex32"}, {\tt "c32"}  \\
\podt{complex}{64}  &   {\tt "complex64"}, {\tt "c64"}  \\
\podt{complex}{128} &   {\tt "complex128"}, {\tt "c128"}  \\
\dtype{string}      &   {\tt "string"}, {\tt "str"}  \\
\dtype{binary}      &   {\tt "binary"} , {\tt binary}  \\
\hline
\end{tabular}
\caption{\small\label{tab:types:type_str} Data types and their string
representations.}
\end{minipage}
\end{table}

%%%============================================================================
The recommended way to deal with type information at runtime are the
{\tt type\_id\_t} enumerations.
At some point in time a program might has to determine the type ID of a variable
type or of the element type of a container.  The basic facility to achieve this
is the {\tt type\_id} function defined in {\tt pni/core/type\_utils.hpp}.  The
usage of this function is rather simple as shown here
\begin{minted}[frame=lines]{cpp}
#incldue<pni/core/types.hpp>

using namespace pni::core;

//one could use this with 
auto data = get_data(...);

std::cout<<type_id(data)<<std::endl;
\end{minted}
The important thing to notice here is that no matter what type the {\tt
get\_data} function returns, {\tt type\_id} will give you the type ID.

Another important scenario is the situation where a user uses the string
representation to tell a program with which type it should work. 
In such a situation you either want to convert the string representation of a
type into a value of {\tt type\_id\_t} or vica verse. The library provides two
functions for this purpose {\tt type\_id\_from\_str} which converts the string
representation of a type to a value of {\tt type\_id\_t} and 
{\tt str\_from\_type\_id} which performs the opposite operation. 
The usage of this two guys is again straight forward.
\begin{minted}[linenos,frame=lines]{cpp}
    #include <pni/core/types.hpp>
    #include <pni/core/type_utils.hpp>

    using namespace pni::core;

    //get a type id from a string
    string rep = "string";
    type_id_t id = type_id_from_str("str");

    //get a string from a type id
    rep = str_from_type_id(type_id_t::FLOAT32);
\end{minted}


\section{Using the {\tt binary} type}\label{section:using_binary}

In many cases uninterpreted binary data should be transfered from one location
to the other (a typical example would be to copy the content of one file to
another).
Typically one would use a {\tt typdef} to something like {\tt uint8} to realize
such a type. However, this approach has two disadvantages
\begin{enumerate}
\item as {\tt uint8} is a numeric type with all arithmetic operators available
which we do not want for uninterpreted binary data 
\item a mere {\tt typedef} would make {\tt uint8} and {\tt binary} 
indistinguishable and thus we could not specialize template classes for each of
them.
\end{enumerate}
Consequently {\tt binary} was implemented as a thin wrapper around an
appropriately sized integer type with all arithmetic operators stripped away.
A short example of how to use binary is the {\tt copy\_file.cpp} example in the
{\tt examples} directory of the source distribution of {\tt libpnicore}. 

\inputminted[linenos,firstline=24,frame=lines]{cpp}{../examples/copy_file.cpp}

In lines $8$ and $10$ we include the {\tt pni/core/types.hpp} header file and
instruct the compiler to use the {\tt pni::core} namespace by default. In line
$12$ a vector type with binary elements is defined and an instance of this type
is allocated in line $24$. 
In line $27$ data is read from the input file and stored in the vector. Now, it
is clear from here that a vector of type  {\tt char} would have perfectly served
the same purpose. The major difference is that unlike {\tt char} {\tt binary}
has absolutely no semantics. In practice there is nothing much you can do
without it rather than store it back to another stream as it is done in 
line $33$.
