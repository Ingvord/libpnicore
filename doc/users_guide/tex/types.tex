%%%documentation on data types

\newcommand{\dtype}[1]{\texttt{#1}}
\newcommand{\podt}[2]{\dtype{#1#2}}
\newcommand{\typeid}[1]{\texttt{type\_id\_t::#1}}
\newcommand{\typeclass}[1]{\texttt{ type\_class\_t::#1}}
\newcommand{\typeidmap}{\texttt{type\_id\_map}}
\newcommand{\idtypemap}{\texttt{id\_type\_map}}
\newcommand{\typeclassmap}{\texttt{type\_class\_map}}
\newcommand{\strrep}[1]{\texttt{"#1"}}
\newcommand{\unchecked}{\textcolor{ForestGreen}{U}}
\newcommand{\checked}{\textcolor{blue}{C}}
\newcommand{\none}{\textcolor{red}{N}}


%%%---------------------------------------------------------------------------
\begin{table}[tb]
\centering
\begin{tabular}{l|l|l|p{0.36\linewidth}}
\hline
\texttt{type\_class\_t::} & data type & \texttt{type\_id\_t::} & description \\
\hline\hline
\multirow{8}{*} {\cpp{INTEGER}} & 
   \podt{uint}{8}   & \cpp{UINT8}  & 8Bit unsinged integer \\
 & \podt{int}{8}    & \cpp{INT8}   & 8Bit signed integer   \\
 & \podt{uint}{16}  & \cpp{UINT16} & 16Bit unsigned integer\\
 & \podt{int}{16}   & \cpp{INT16}  & 16Bit signed integer  \\
 & \podt{uint}{32}  & \cpp{UINT32} & 32Bit unsigned integer\\
 & \podt{int}{32}   & \cpp{INT32}  & 32Bit signed integer  \\
 & \podt{uint}{64}  & \cpp{UINT64} & 64Bit unsigned integer\\
 & \podt{int}{64}   & \cpp{INT64}  & 64Bit signed integer  \\
\hline
\multirow{3}{*}{\cpp{FLOAT}} & 
  \podt{float}{32}  & \cpp{FLOAT32}  & 32Bit IEEE floating point type  \\
& \podt{float}{64}  & \cpp{FLOAT64}  & 64Bit IEEE floating point type  \\
& \podt{float}{128} & \cpp{FLOAT128} & 128Bit IEEE floating point type \\
\hline
\multirow{3}{*}{\cpp{COMPLEX}} & 
   \podt{complex}{32}  & \cpp{COMPLEX32} & 32Bit IEEE complex float type   \\
 & \podt{complex}{64}  & \cpp{COMPLEX64} &64Bit IEEE complex float type    \\
 & \podt{complex}{128} & \cpp{COMPLEX128} & 128Bit IEEE complex float type \\
\hline
\cpp{STRING} & \dtype{string}  & \cpp{STRING} & string  type  \\
\hline
\cpp{BINARY} & \dtype{binary}  & \cpp{BINARY} & binary type   \\
\hline
\cpp{NONE}   & \dtype{none}    & \cpp{NONE}   & none type     \\
\hline
\end{tabular}
\caption{\small\label{tab:types:basic_types} An overview of the primitive data
types provided by \libpnicore.}
\end{table}
%%%===================================================================================
\libpnicore\ provides a set of data types of well defined size and utility
functions related to type management. 
The basic header file required to use \libpnicore s type facilities is 
\begin{cppcode}
#include <pni/core/types.hpp>
\end{cppcode}
The data types provided by \libpnicore\ include
\begin{enumerate}
\item numeric types with all their arithmetic operations
\item string types (currently only one member)
\item and utility types like \dtype{binary}, \dtype{bool}, and \dtype{none}.
\end{enumerate}
All this types together are refered to as \emph{ primitive types}.
The numeric types are ensured to have the same size on each
platform and architecture supported by \libpnicore. They are mostly
\cpp{typedef}s to the types defined by the C standard library.  However, the
utility types \dtype{binary}, \dtype{bool}, and \dtype{none} are unique to
\libpnicore\ and will be explained in more detail in the last sections of this
chapter.

Every type in \libpnicore\ is associated with an ID represented by the 
\cpp{type\_id\_t} enumeration type. Additionally every type belongs to a
particular type class defined by the \cpp{type\_class\_t} enumeration type.
Table~\ref{tab:types:basic_types} gives an overview over the primitive types
provided by \libpnicore\ and their corresponding \cpp{type\_id\_t} and
\cpp{type\_class\_t} values.

\section{Compile time type identification}

To obtain the ID or class of a type at compile time use the 
\typeidmap\ or \typeclassmap\ type maps. 
\begin{cppcode}
#include <pni/core/types.hpp>

using namespace pni::core;

//determine the type ID for a given type
type_id_map<float32>::type_id == type_id_t::FLOAT32;

//obtain the class of a particular type
type_class_map<float32>::type_class == type_class_t::FLOAT;
\end{cppcode}
For IDs the other way around is also possible with the \idtypemap 
\begin{cppcode}
#include <pni/core/types.hpp>

using namespace pni::core;

//determine the type for a given ID
id_type_map<type_id_t::FLOAT32>::type data = ...;
\end{cppcode}
For numeric types there are also some other templates for a more detailed type
classification 
\begin{center}
\begin{tabular}{ll}
\cpp{is\_integer\_type<T>::value} & \cpp{true} if \cpp{T} is an integer type\\
\cpp{is\_float\_type<T>::value} & \cpp{true} if \cpp{T} is a floating point type\\
\cpp{is\_complex\_type<T>::value} & \cpp{true} if \cpp{T} is a complex number
type\\
\cpp{is\_numeric\_type<T>::value} & \cpp{true} if \cpp{T} is any of the above
types\\
\end{tabular}
\end{center}



\section{Identifying types at runtime}
%%%============================================================================
\begin{table}[tb]
\centering
\begin{minipage}[t]{0.49\linewidth}
\centering
\begin{tabular}{l|p{0.48\linewidth}}
\hline
data type & string representation \\
\hline\hline
\podt{uint}{8}      &   \strrep{uint8} , \strrep{ui8} \\
\podt{int}{8}       &   \strrep{int8} ,  \strrep{i8}   \\
\podt{uint}{16}     &   \strrep{uint16}, \strrep{ui16}  \\
\podt{int}{16}      &   \strrep{int16},  \strrep{i16}   \\
\podt{uint}{32}     &   \strrep{uint32}, \strrep{ui32}   \\
\podt{int}{32}      &   \strrep{int32},  \strrep{i32}  \\
\podt{uint}{64}     &   \strrep{uint64}, \strrep{ui64}  \\
\podt{int}{64}      &   \strrep{int64},  \strrep{i64}  \\
\podt{float}{32}    &   \strrep{float32},    \strrep{f32}  \\
\podt{float}{64}    &   \strrep{float64},    \strrep{f64}  \\
\podt{float}{128}   &   \strrep{float128},   \strrep{f128}  \\
\podt{complex}{32}  &   \strrep{complex32},  \strrep{c32}  \\
\podt{complex}{64}  &   \strrep{complex64},  \strrep{c64} \\
\podt{complex}{128} &   \strrep{complex128}, \strrep{c128}  \\
\dtype{string}      &   \strrep{string},     \strrep{str}  \\
\dtype{binary}      &   \strrep{binary},     \strrep{binary}  \\
\dtype{none}        &   \strrep{none} \\
\hline
\end{tabular}
\caption{\small\label{tab:types:type_str} Data types and their string
representations.}
\end{minipage}
\end{table}

%%%============================================================================
The recommended way to deal with type information at runtime are the
\texttt{type\_id\_t} enumerations.
At some point in time a program might has to determine the type ID of a variable
type or of the element type of a container.  The basic facility to achieve this
is the \texttt{type\_id} function defined in \texttt{pni/core/type\_utils.hpp}.  The
usage of this function is rather simple as shown here
\begin{minted}[frame=lines]{cpp}
#incldue<pni/core/types.hpp>

using namespace pni::core;

//one could use this with 
auto data = get_data(...);

std::cout<<type_id(data)<<std::endl;
\end{minted}
The important thing to notice here is that no matter what type the \texttt{
get\_data} function returns, \texttt{type\_id} will give you the type ID.
In cases where the type ID is given and a classification of the type 
has to be made four functions are provided where each takes a type ID as 
its single most argument
\begin{center}
\begin{tabular}{ll}
    \cpp{is\_integer(type\_id\_t)} & returns true if the type ID refers 
    to an integer type \\
    \cpp{is\_float(type\_id\_t)} & returns true if the type ID refers 
    to a float type \\
    \cpp{is\_complex(type\_id\_t)} & returns true if the type ID refers 
    to a complex type \\
    \cpp{is\_numeric(type\_id\_t)} & returns true if the type ID refers 
    to a numeric type \\
\end{tabular}
\end{center}

Another important scenario is the situation where a user uses the string
representation to tell a program with which type it should work. 
In such a situation you either want to convert the string representation of a
type into a value of \texttt{type\_id\_t} or vica verse. The library provides two
functions for this purpose \texttt{type\_id\_from\_str} which converts the string
representation of a type to a value of \texttt{type\_id\_t} and 
\texttt{str\_from\_type\_id} which performs the opposite operation. 
The usage of this two guys is again straight forward.
\begin{minted}[linenos,frame=lines]{cpp}
    #include <pni/core/types.hpp>
    #include <pni/core/type_utils.hpp>

    using namespace pni::core;

    //get a type id from a string
    string rep = "string";
    type_id_t id = type_id_from_str("str");

    //get a string from a type id
    rep = str_from_type_id(type_id_t::FLOAT32);
\end{minted}


%%%===========================================================================
\section{The \texttt{binary} type}\label{section:using_binary}

In many cases uninterpreted binary data should be transfered from one location
to the other (a typical example would be to copy the content of one file to
another).
Typically one would use a \texttt{ typdef} to something like \texttt{uint8} to realize
such a type. However, this approach has two disadvantages
\begin{enumerate}
\item as \texttt{uint8} is a numeric type with all arithmetic operators available
which we do not want for uninterpreted binary data 
\item a mere \texttt{typedef} would make \texttt{uint8} and \texttt{binary} 
indistinguishable and thus we could not specialize template classes for each of
them.
\end{enumerate}
Consequently \texttt{binary} was implemented as a thin wrapper around an
appropriately sized integer type with all arithmetic operators stripped away.
A short example of how to use binary is the \texttt{copy\_file.cpp} example in the
\texttt{examples} directory of the source distribution of \texttt{libpnicore}. 

\inputminted[linenos,
             firstline=24,
             frame=lines,
             label=examples/copy\_file.cpp]
{cpp}{../examples/copy_file.cpp}

In lines $8$ and $10$ we include the \texttt{pni/core/types.hpp} header file and
instruct the compiler to use the \texttt{pni::core} namespace by default. In line
$12$ a vector type with binary elements is defined and an instance of this type
is allocated in line $24$. 
In line $27$ data is read from the input file and stored in the vector. Now, it
is clear from here that a vector of type  \texttt{char} would have perfectly served
the same purpose. The major difference is that unlike \texttt{char} \texttt{binary}
has absolutely no semantics. In practice there is nothing much you can do
without it rather than store it back to another stream as it is done in 
line $33$.

%%%===========================================================================
\section{The \cpp{none} type}\label{section:using_none}

The \cpp{none} type represents the absence of a type. It is a dummy type 
of very limited functionality and is mainly used internally by 
\libpnicore. One major application of the \cpp{none} type is to do default
construction of type erasures (see chapter~\ref{chapter:type_erasures}). 
For all practical purposes this type can be ignored.

%%%===========================================================================
\section{The \cpp{bool\_t} type}\label{section:using_bool}

Unlike the \cpp{C} programming language C++ provides a native \cpp{bool} type. 
Unfortunately the \cpp{C++} standardization committee made some unfortunate 
decisions with \cpp{bool} and STL containers. \cpp{std::vector} for instance is
in most cases specialized for the standard \cpp{C++} \cpp{bool} type. 
In the most common STL implementation {\cpp std::vector} is considered an 
array of individual bits. Meaning that every byte in the vector is storing a
total of $8$ \cpp{bool} values. Consequently we cannot obtain an address 
for a particular bit but only for the byte where it is stored. 
Hence \cpp{std::vector<bool>} does not provide the \cpp{data} method 
which is required for storage containers used with the \cpp{mdarray} templates
(see chapter~\ref{chapter:arrays}). 

To overcome this problem a new boolean type was included in \libpnicore\ which 
can be converted to \cpp{bool} but uses a single byte for each boolean value and
thus can use the \cpp{std::vector} template. So use the \libpnicore\
\cpp{bool\_t} type whenever working with \libpnicore\ templates or whenever the
address of a container element is required. For all other purposes the default
C++ \cpp{bool} type can be used.

%%%===========================================================================
\section{Numeric type conversion}

\libpnicore\ provides facilities for save numeric type conversion. These
functions are not only used internally by the library they are also available to
users.  The conversion policy enforced by \libpnicore\ is more strict than that
of standard C++. For instance you cannot convert a negative integer to an
unsigned integer type. The goal of the conversion rules are set up in order to
avoid truncation errors as they would typically occur when using the standard
C++ rules.

The basic rule for conversion between two integer type A and B is as follows
\begin{quote}
    A value of type \cpp{S} can only be converted to type \cpp{B} if the value
    does not exceed the numeric range of type \cpp{B}.
\end{quote}
A consequence of this rule is that a signed integer can only be converted 
to an unsigned type if its value is larger than $0$. This is different 
from the standard C++ rule where the unsigned target type will just overflow. 

The second basic rule which governs \libpnicore s conversion policy is 
\begin{quote}
    During a conversion no information must be lost!
\end{quote}
Hence, conversion from a floating point type to an integer type is prohibited as
it would most likely lead to truncation and thus a loss of information. 
Conversion from a scalar float value to a complex value is allowed (as long as
the first rule applies to the base type of the complex type) but one cannot
convert a complex value to a scalar float type.

Several types cannot be converted to anything than themselves 
\begin{itemize}
    \item \texttt{bool\_t} which can be only the result of a boolean 
        operation.
    \item \texttt{binary} as this type is considered to be a completely 
        opaque type conversion to any other type is prohibited. Furthermore no
        type can be converted to binary. 
    \item \texttt{string} conversion to string is done exclusively carried out by 
        formatters provided by the IO library. 
\end{itemize}

The library distinguishes between two kinds of type conversion
\begin{description}
    \item[unchecked conversion] the conversion can be done without checking the
        value
    \item[checked conversion] the value has to be checked if it fits into the 
        target type.
\end{description}
Table~\ref{tab:types:unchecked_conversions} gives an overview between which
types conversion is possible and whether unchecked or checked conversion will be
used. 
%%%---------------------------------------------------------------------------
\begin{landscape}
    \begin{table}
    \centering
\begin{tabular}{c||c|c|c|c||c|c|c|c||c|c|c||c|c|c}
    \hline
source / target& \podt{ui}{8} & \podt{ui}{16} & \podt{ui}{32} & \podt{ui}{64} & 
                 \podt{i}{8}  & \podt{i}{16}  & \podt{i}{32}  & \podt{i}{64} & 
                 \podt{f}{32} & \podt{f}{64}  & \podt{f}{128} & 
                 \podt{c}{32} & \podt{c}{64}  & \podt{c}{128} \\
\hline\hline
\podt{ui}{8}     & \unchecked & \unchecked & \unchecked & \unchecked & 
                   \checked & \unchecked & \unchecked & \unchecked & 
                   \unchecked & \unchecked & \unchecked & 
                   \unchecked & \unchecked & \unchecked \\
\hline
\podt{ui}{16}    & \checked & \unchecked & \unchecked & \unchecked & 
                   \checked & \checked & \unchecked & \unchecked & 
                   \unchecked & \unchecked & \unchecked & 
                   \unchecked & \unchecked & \unchecked \\
\hline
\podt{ui}{32}    & \checked & \checked & \unchecked & \unchecked & 
                   \checked & \checked & \checked & \unchecked & 
                   \unchecked & \unchecked & \unchecked & 
                   \unchecked & \unchecked & \unchecked \\
\hline
\podt{ui}{64}    & \checked & \checked & \checked & \unchecked & 
                   \checked & \checked & \checked & \checked & 
                   \unchecked & \unchecked & \unchecked & 
                   \unchecked & \unchecked & \unchecked \\
\hline\hline
\podt{i}{8}      & \checked & \checked & \checked & \checked & 
                   \unchecked & \unchecked & \unchecked & \unchecked & 
                   \unchecked & \unchecked & \unchecked & 
                   \unchecked & \unchecked & \unchecked \\
\hline
\podt{i}{16}     & \checked & \checked & \checked & \checked & 
                   \checked & \unchecked & \unchecked & \unchecked & 
                   \unchecked & \unchecked & \unchecked & 
                   \unchecked & \unchecked & \unchecked \\
\hline
\podt{i}{32}     & \checked & \checked & \checked & \checked & 
                   \checked & \checked & \unchecked & \unchecked & 
                   \unchecked & \unchecked & \unchecked & 
                   \unchecked & \unchecked & \unchecked \\
\hline
\podt{i}{64}     & \checked & \checked & \checked & \checked & 
                   \checked & \checked & \checked & \unchecked & 
                   \unchecked & \unchecked & \unchecked & 
                   \unchecked & \unchecked & \unchecked \\
\hline\hline
\podt{f}{32}     & \none & \none & \none & \none & 
                   \none & \none & \none & \none & 
                   \unchecked & \unchecked & \unchecked & 
                   \unchecked & \unchecked & \unchecked \\
\hline
\podt{f}{64}     & \none & \none & \none & \none & 
                   \none & \none & \none & \none & 
                   \checked & \unchecked & \unchecked & 
                   \checked & \unchecked & \unchecked \\
\hline
\podt{f}{128}    & \none & \none & \none & \none & 
                   \none & \none & \none & \none & 
                   \checked & \checked & \unchecked & 
                   \checked & \checked & \unchecked \\
\hline\hline
\podt{c}{32}     & \none & \none & \none & \none & 
                   \none & \none & \none & \none & 
                   \none & \none & \none & 
                   \unchecked & \unchecked & \unchecked \\
\hline
\podt{c}{64}     & \none & \none & \none & \none & 
                   \none & \none & \none & \none & 
                   \none & \none & \none & 
                   \checked & \unchecked & \unchecked \\
\hline
\podt{c}{128}    & \none & \none & \none & \none & 
                   \none & \none & \none & \none & 
                   \none & \none & \none & 
                   \checked & \checked & \unchecked \\
\hline
\end{tabular}
\caption{{\small\label{tab:types:unchecked_conversion}
Type matrix showing between which types  conversion is possible. \cpp{U} and
\cpp{C} denote unchecked and checked type conversion. \cpp{N} indicates 
type pairs where conversion is impossible as it would violate one of the 
conversion policies mentioned in the text.}}
\end{table}
\end{landscape}

\subsection{The \cpp{convert} function template}

At the heart of \libpnicore s type conversion system is the \cpp{convert}
function template. The declaration of the template looks somehow like this
\begin{cppcode}
template<typename ST,typename TT> TT convert(const ST &v);
\end{cppcode}
A value of a particular source type (denoted by the template parameter 
\cpp{ST}) is passed as an argument to the \cpp{convert} template. The value 
of this argument will then be converted to a value of the target type 
\cpp{TT} and returned from the function template. 
This function template throws two exceptions
\begin{center}
\begin{tabular}{ll}
\cpp{type\_error} & in situations where the type conversion is not possible \\
\cpp{range\_error} & where the source value does not fit into the target type
\end{tabular}
\end{center}
The behavior of this function can best be demonstrated examples. 
\begin{cppcode}
auto f = convert<float32>(int32(5)); 
\end{cppcode}
In this example a value of type \cpp{int32} is successfully converted 
to a value of type \cpp{float32}, while
\begin{cppcode}
auto f = convert<uint16>(float32(-5)); // throws type_error
\end{cppcode}
leads to \cpp{type\_error}. According to the conversion policies mentioned above
a float value cannot be converted to an integer due to truncation issues. 
\begin{cppcode}
auto f = convert<uint32>(int32(-3)); //throws range_error
\end{cppcode}
\cpp{range\_error} will be thrown as a negative value cannot be converted to an 
unsigned type. A similar situation would be 
\begin{cppcode}
auto f = convert<uint8>(int16(10000)); //throws range_error
\end{cppcode}
where \cpp{range\_error} would indicate that it is impossible to store a value 
of $10000$ in an $8$-Bit unsigned variable.



