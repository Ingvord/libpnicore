%%% Dealing with type erasures

%%%============================================================================
Templates are powerful tools as they allow the compiler to perform all kinds of
optimizations. In addition they help to avoid virtual function tables and thus
increasing overall performance of a program. 
Template instantiation virtually always goes along with code generation and thus
with an increase in code size. This can cause problems in particular on small
hardware (like ARM based systems) where resources are limited.
Think about the \texttt{show\_info} function template in the previous chapter. The
function will be instantiated for every array type passed to it although it does
virtually the same thing for each of them (we see an example of this in the
section below describing the array type erasure). 

A reasonable solution for this problem is the use of type erasures. 
\libpnicore\ provides three different type erasures
\begin{center}
\begin{tabular}{l | l}
\texttt{value} & stores a single scalar value of a POD type \\
\texttt{value\_ref} & stores the reference to an instance of a POD type \\
\texttt{array} & stores a multidimensional array type 
\end{tabular}
\end{center}
To use type erasures include the \texttt{/pni/core/type\_erasures.hpp} at the top of
your source file.

%%%============================================================================
\section{The \texttt{value} type erasures}

The \texttt{value} type erasure stores the value of a single scalar POD type. 
\texttt{value} can be default constructed in which case an instance of type 
\texttt{none} is stored as can be easily confirmed with
\begin{cppcode}
value v;
std::cout<<v.type_id()<<std::endl; //output NONE
\end{cppcode}
\texttt{value} has a copy and move constructor for other instances from 
\texttt{value}. However, the constructor for other variables and literals is 
explicit 
\begin{cppcode}
//explicit construction from a variable
int32 n = 1000;
value v1(n);     
std::cout<<v1.type_id()<<std::endl; //output INT32

//explicit construction from a literal
value v2(3.4212); 
std::cout<<v2.type_id()<<std::endl; //output FLOAT64

//copy construction
value v3 = v1;
\end{cppcode}
\texttt{value} also allows copy and move assignment from other instances of
\texttt{value} as well as from literals. In all cases the assignment can change the
stored data type
\begin{cppcode}
value v1,v2;  //default constructed  (type NONE)

//copy assignment from literal
v1 = 32;  
std::cout<<v1.type_id()<<std::endl;  //output INT32

v2 = v1;
std::cout<<v2.type_id()<<std::endl;  //output INT32
\end{cppcode}
If default construction is required but the type of the internal value should
not be \cpp{none} one can use the \cpp{make\_value} function template 
\begin{cppcode}
auto v = make_value<float128>();
std::cout<<v.type_id()<<std::endl; //output: FLOAT128
\end{cppcode}
This function template is particularly useful in connection with input- and
output-streams as will be shown later. 

To retrieve the data stored in an instance of \cpp{value} use the \cpp{as}
member template function as shown in this next example
\begin{cppcode}
value v(float64(1.23));

auto x = v.as<float64>();

std::cout<<x<<std::endl;
\end{cppcode}
There are tow things which are important here: first, the type checking is very
strict. To successfully retrieve the data value from the \cpp{value} instance
the type passed as the template parameter must be exactly the equal to the type
used to construct the \cpp{value} instance. Otherwise \cpp{type\_error} will be
thrown. In addition, one cannot retrieve the value from a default constructed
instance of \cpp{value} (the one which is of type \cpp{none}). In this case 
\cpp{type\_error} will be thrown too.

The \cpp{value} type erasure can be used with the standard C++ input and output
streams
\begin{cppcode}
auto value = make_value<float32>();
std::cin>>value;

std::cout<<value;
\end{cppcode}
however, it is necessary to create a default value whose type is not
\cpp{none}.

%%%===========================================================================
\section{The \cpp{value\_ref} type erasure}

The \cpp{value} type takes over ownership over the stored value. 
In some cases one may wants to use a type erasures to a reference of a
particular type.  For this purpose \libpnicore\ provides the \cpp{value\_ref}
type erasure as shown in the next example

\inputminted[fontsize=\small,
             linenos,
             firstnumber=26,
             firstline=26,
             lastline=45,
             frame=lines,
             label=examples/type\_erasure2.cpp]
{cpp}{../examples/type_erasure2.cpp}
Unlike \cpp{value} \cpp{value\_ref} does not take ownership over the object
whose type should be erased but rather holds a reference to it
as demonstrated by the output of the program
\begin{minted}{bash}
10.234
2334.5
2334.5
\end{minted}
It is possible to alter the value of the original variable via an instance of
the \texttt{value\_ref} type erasure.

In fact \cpp{value\_ref} is a wrapper around the \cpp{std::reference\_wrapper} 
template provided by C++. Therefore, as shown in line $36$ in the above example
it has to be constructed from such a type. 
As the \cpp{value} type erasure it provides a \cpp{as<>} template method and a
\cpp{type\_id} method.
\cpp{value\_ref} provides a default constructor. However, every attempt to 
access the data of a default constructed \cpp{value\_ref} instance will throw
a \cpp{memory\_not\_allocated} exception. This behavior is sensible as one 
tries to access a not initialized reference. In addition the behavior of the 
assignment operator for \cpp{value\_ref} is slightly more complex than that of 
\cpp{value} as demonstrated in the next example
\begin{cppcode}
float64 n = 234.2;
value v = 1.234;
value_ref vr(std::ref(n));

vr = 54.1334; //assigns a new value to n and vr
vr = v;       //assigns a new value to n and vr

float64 n2 = 10000;
value_ref vi(std::ref(n2));

vr = vi;      //rebinds the vr to n2
\end{cppcode}
In the first two cases a new value is assigned to \cpp{vr} while in the latter
case the assignment between two instances of \cpp{value\_ref} causes a rebind of
\cpp{vr} to the variable $n2$. This may cause some trouble. If only the value of
a reference should be assigned we need to use the \cpp{static\_cast} function
and replace the last line with
\begin{cppcode}
vr = static_cast<value>(vi);
\end{cppcode}
By casting to \cpp{value}  we do not have to care about the particular data type
held by \cpp{vi}. However, one must take care that the types do match, otherwise
a \cpp{type\_error} exception will be thrown.

%%%============================================================================
\section{Type erasures for arrays}

As \libpnicore\ provides a virtually indefinite number of array types via its
\cpp{mdarray} template the \cpp{array} type erasure is maybe one of the most
important ones. Like the \cpp{value} type erasure it will take over full
ownership of the array stored in it.

A good introduction into the \cpp{array} type erasure is this particular version
of the array inquiry  example from the previous chapter on arrays. 
\inputminted[linenos,
             fontsize=\small,
             firstnumber=25,
             firstline=25,
             lastline=62,
             frame=lines,
             label=examples/type\_erasure3.cpp]
{cpp}{../examples/type_erasure3.cpp}
In the previous version, where \cpp{show\_info} was a template function a new
version of \cpp{show\_info} would have been created for each of the three array
types used in this example. By using the type erasure only a single version of
\cpp{show\_info} is required which reduces the total code size of the binary.

The current implementation of \cpp{array} is rather limited in comparison 
to the \cpp{mdarray} template. Multidimensional access is not provided and only
forward iteration is implemented. In addition there is now \cpp{array\_ref} 
type erasure which only keeps a reference to an instance of \cpp{mdarray}. 

The iterators themselves have a subtle speciality. They do not provide a
\cpp{->} operator. This has a rather simple reason. While all other interators
return a pointer to a particular data element in a container the \cpp{array}
iterators cannot do this (they do no hold any type information). Instead they
return an instance of \cpp{value} for constant or \cpp{value\_ref} for
read/write iterators. In order to keep the semantics of the \cpp{->} operator we
would have to return \cpp{*value} or \cpp{*value\_ref} from the \cpp{->}
operator. However, this is not possible as these objects are just temporaries
and would be destroyed once the operator function has returned. 
However, this is only a small inconvenience as it has no influence on the 
STL compliance of the iterator. 
One can still use the \cpp{foreach} construction
\begin{cppcode}
array a(...);

for(auto x: a)
    std::cout<<s<<std::endl;
\end{cppcode}
and all STL algorithms with a \cpp{array} type erasure.


%%%============================================================================
\section{An example: reading tabular ASCII data}

In this final section a typical use-case for a type erasure will be discussed. 
One problem that regularly pops up is to read tabular ASCII data. 
For this example a very simple file format has been used. The file
\cpp{record.dat}
has the following content
\inputminted[fontsize=\small,
             frame=lines,
             label=examples/record.dat]
{text}{../examples/record.dat}
While the elements of the first two columns are integer and float respectively,
the third column holds complex numbers. The task is simple: read the values from
the file without losing information. This means that we do not want to truncate
values (for instance float to integer) or do inappropriate type conversions (for
instance convert everything to the complex type) which may add rounding errors. 

There are several ways how to approach this problem. The most straight forward
one would be to create a \cpp{struct} with an integer, a float, and a complex
element. However, this approach is rather static. If a column will be added or
removed or only the order of the columns is changed we have to alter the code. 

In this example a different path has been taken. Each individual line is
represented by a record type which consists of a vector whose elements are
instances of the \cpp{value} type erasure.   
\inputminted[linenos,
             fontsize=\small,
             firstnumber=26,
             firstline=26,
             lastline=40,
             frame=lines,
             label=examples/type\_erasure\_record.cpp
             ]
{cpp}{../examples/type_erasure_record.cpp}
The entire table is again a vector with \cpp{record\_type} as element type.
In addition we have defined a special type to store complex numbers
(\cpp{complex\_type}).

\subsection{Defining the parsers}

One of the key elements for this example is to use the \cpp{boost::spirit}
parser framework. We define three parsers
\begin{enumerate}
\item one for the \cpp{complex\_type}
\item one for a value which can parser integer, double, and complex numbers
\item and one for the entire record.
\end{enumerate}
The \cpp{boost::spirit} framwork is indeed rather complex and requires a deep
understanding of some of the additional boost libraries like \cpp{fusion} and
\cpp{phoenix}. However, as we will see, it is worth to become familiar with them
as will be shown here.
\todo{Add a reference for the boost documentation here}

In this next snippet the definition of the complex number parser is shown. 
\inputminted[linenos,
             fontsize=\small,
             firstnumber=45,
             firstline=45,
             lastline=61,
             frame=lines,
             label=examples/type\_erasure\_record.cpp
             ]
{cpp}{../examples/type_erasure_record.cpp}
We assume complex numbers to be stored as tuples of the form \cpp{(real
part,imaginary part)}. As we can see in the above example the complex type is
assembled from the two double values matched in the rule. The next parser
required is the value parser. This parser matches either an integer, a double,
or a complex value. It is a good example how to reuse already existing 
parser in \cpp{boost::spirit}. 
\inputminted[linenos,
             fontsize=\small,
             firstnumber=66,
             firstline=66,
             lastline=89,
             frame=lines,
             label=examples/type\_erasure\_record.cpp
             ]
{cpp}{../examples/type_erasure_record.cpp}
Finally we need a parser for the entire record. This is rather simple as
\cpp{boost::spirit} provides a special syntax for parsers who store their
results in containers.
\inputminted[linenos,
             fontsize=\small,
             firstnumber=94,
             firstline=94,
             lastline=107,
             frame=lines,
             label=examples/type\_erasure\_record.cpp
             ]
{cpp}{../examples/type_erasure_record.cpp}

\subsection{The main program}

The main program is rather simple 
\inputminted[linenos,
             fontsize=\small,
             firstnumber=162,
             firstline=162,
             lastline=175,
             frame=lines,
             label=examples/type\_erasure\_record.cpp
             ]
{cpp}{../examples/type_erasure_record.cpp}
Not all the code will be explained as it is only those parts which are of
interest for the \cpp{value} type erasure.
The program can be divided into two parts:
\begin{enumerate}
\item reading the data (in line $166$) 
\item and writing it back to standard output (in line $172$)
\end{enumerate}
As the latter one is rather trivial we will only consider the reading part in
this document. The output of the main function is 
\begin{minted}[fontsize=\small,frame=lines]{bash}
INT32
FLOAT64
COMPLEX32
11      -123.23 (-1,0.23)
13      -12.343 (12.23,-0.2)
16      134.12  (1.23,-12.23)
\end{minted}

\subsection{The reading sequence}

The entry point for the read sequence is the \cpp{read\_table} function.
\inputminted[linenos,
             fontsize=\small,
             firstnumber=128,
             firstline=128,
             lastline=141,
             frame=lines,
             label=examples/type\_erasure\_record.cpp
             ]
{cpp}{../examples/type_erasure_record.cpp}
The logic of this function is rather straight forward. Individual lines are
written from the input stream until \cpp{EOF} and passed on to the
\cpp{parse\_record} function which returns an instance of \cpp{record\_type}. 
Each record is appended to the table. 

The \cpp{parse\_record} function is where all the magic happens
\inputminted[linenos,
             fontsize=\small,
             firstnumber=112,
             firstline=112,
             lastline=123,
             frame=lines,
             label=examples/type\_erasure\_record.cpp
             ]
{cpp}{../examples/type_erasure_record.cpp}
The definition of this function pretty much demonstrates the power of the
\cpp{boost::spirit} library. All the nasty parsing work is done by the code 
provided by \cpp{boost::spirit}. The only thing left to do is provide iterators
to the beginning and end of the line.


