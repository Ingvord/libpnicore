%%% Dealing with type erasures

%%%============================================================================
Templates are powerful tools as they allow the compiler to perform all kinds of
optimizations.In addition they help to avoid virtual functions in classes and
thus increase performance by avoiding call indirection through the virtual
functions table. However, there are two major obstacles with templates
\begin{enumerate}
\item template expansion virtually always leas to code generation and this could 
lead to large binaries which might be a problem on small hardware architectures
\item template libraries and the applications which are using them are harder 
to maintain. 
\end{enumerate}
The last point may requires a bit of explanation. The reason why system
administrators are not very happy with programs based on template libraries is
that the latter ones are distributed as source code. 
Consequently whenever a bug is fixed in the library all programs depending 
on the code required recompilation. For programs using binary libraries only the
library has to be updated. This is obviously much easier than recompiling 
all the programs depending on a library. 

A reasonable solution for this problem is the use of type erasures. 
\libpnicore\ provides three different type erasures
\begin{center}
\begin{tabular}{l | l}
\texttt{value} & stores a single scalar value of a POD type \\
\texttt{value\_ref} & stores the reference to an instance of a POD type \\
\texttt{array} & stores a multidimensional array type 
\end{tabular}
\end{center}
To use type erasures include the \cpp{/pni/core/type\_erasures.hpp} at the top of
your source file.

%%%============================================================================
\section{The \cpp{value} type erasures}

\subsection{Construction}
The \cpp{value} type erasure stores the value of a single primitive type. 
Whenever an instance of \cpp{value} is constructed memory is allocated 
large enough to store the value of a particular type. 

\cpp{value} provides a default constructor. The instance produced by the 
default constructor holds a value of type \cpp{none}. \begin{cppcode}
value v;
std::cout<<v.type_id()<<std::endl; //output NONE
\end{cppcode}
Though there is not too much one can do with such a type it has the nice 
advantage that one can default construct an instance of type \cpp{value}.
In addition a copy and a move constructor is provided. All these constructors
are implicit. 

The more interesting constructors are explicit. An instance of \cpp{value} 
can be constructed either from a variable from a particular type or from a
literal as shown in this next example
\begin{cppcode}
//explicit construction from a variable
int32 n = 1000;
value v1(n);     
std::cout<<v1.type_id()<<std::endl; //output INT32

//explicit construction from a literal
value v2(3.4212); 
std::cout<<v2.type_id()<<std::endl; //output FLOAT64

//copy construction
value v3 = v1;
\end{cppcode}

As mentioned earlier in this section, whenever an instance of \cpp{value} 
is constructed, memory is allocated to store the quantity that should be 
hidden in the type erasure. The default constructor would allocate memory for a 
\cpp{none} type with which one can do nothing useful. 
A typical application for type erasures would be to store primitive values 
of different type in a container and we would like to make the decision 
which type to use at runtime. 
For this purpose one could define a vector type like this
\begin{cppcode}
typedef std::vector<value> value_vector; 
\end{cppcode}
However, how would one initialize an instance of this vector? It would not make
too much sense to use the default constructor (as we cannot pass type
information). The solution to this problem is the \cpp{make\_value} function
which comes in two flavors. The first, as shown in the next code snippet, takes
a type ID as a single argument and returns an instance of \cpp{value} of the 
requested type.
\begin{cppcode}
std::vector<type_id_t>  ids = get_ids();
value_vector values; 

for(auto id: ids)
    values.push_back(make_value(id));
\end{cppcode}
In addition there is a function template which serves the same purpose
\begin{cppcode}
value v = make_value<uint32>();
\end{cppcode}
Here the type is determined by the template parameter of the function template.

\subsection{Assignment}

Copy and move assignment are provided by the \cpp{value} between two of its
instances. In both situations the type of the \cpp{value} instance on the 
left handside of the operator changes (this is obvious). 
Move and copy assignment have the expected semantics. 

The more interesting situation appears with assigning new values to an instance
of \cpp{value}. As memory is only allocated during creation (or copy
assignment) assigning a new value does not create a new instance of
\cpp{value} but rather tries to perform a type conversion between the 
instance of \cpp{value} on the LHS of the operator and the value on the LHS. 
\begin{cppcode}
value v = make_value<float32>(); //creates a value for a float32 value

v = uint16(5); //converts uint16 value to a float32 value
\end{cppcode}
The type conversion follows the same rules as described in the section about 
type conversion earlier in this manual (in fact it uses this functionality). 
Consequently 
\begin{cppcode}
value v = make_value<float64>(); 

v = complex32(3,4); //throws type_error 
\end{cppcode}
will throw a \cpp{type\_error} exception as a complex number cannot be 
converted to a single float value.

\subsection{Retrieving data}

Retrieving data from an instance of \cpp{value} is done via the \cpp{as} 
template method like this
\begin{cppcode}
value v = ....;

auto data = v.as<uint8>();
\end{cppcode}
The template parameter of \cpp{as} determines the data type as which the data
should be retrieved. Like for value assignment the method performs a type
conversion if necessary and throws \cpp{type\_error} or \cpp{range\_error} 
exceptions if the conversion is not possible or the numeric range of the
requested type is too small.

Information about the type of the data stored in the \cpp{value} instance 
can be obtained by means of the \cpp{type\_id} method. 
\begin{cppcode}
value v = ...;
v.type_id();
\end{cppcode}


%%%===========================================================================
\section{The \cpp{value\_ref} type erasure}

The \cpp{value} type takes over ownership over the stored value. 
In some cases one may wants to use a type erasures to a reference of a
particular type.  For this purpose \libpnicore\ provides the \cpp{value\_ref}
type erasure as shown in the next example

\inputminted[fontsize=\small,
             linenos,
             firstnumber=26,
             firstline=26,
             lastline=45,
             frame=lines,
             label=examples/type\_erasure2.cpp]
{cpp}{../examples/type_erasure2.cpp}
Unlike \cpp{value} \cpp{value\_ref} does not take ownership over the object
whose type should be erased but rather holds a reference to it
as demonstrated by the output of the program
\begin{minted}{bash}
10.234
2334.5
2334.5
\end{minted}
It is possible to alter the value of the original variable via an instance of
the \texttt{value\_ref} type erasure.

In fact \cpp{value\_ref} is a wrapper around the \cpp{std::reference\_wrapper} 
template provided by C++. Therefore, as shown in line $36$ in the above example
it has to be constructed from such a type. 
As the \cpp{value} type erasure it provides a \cpp{as<>} template method and a
\cpp{type\_id} method.
\cpp{value\_ref} provides a default constructor. However, every attempt to 
access the data of a default constructed \cpp{value\_ref} instance will throw
a \cpp{memory\_not\_allocated} exception. This behavior is sensible as one 
tries to access a not initialized reference. In addition the behavior of the 
assignment operator for \cpp{value\_ref} is slightly more complex than that of 
\cpp{value} as demonstrated in the next example
\begin{cppcode}
float64 n = 234.2;
value v = 1.234;
value_ref vr(std::ref(n));

vr = 54.1334; //assigns a new value to n and vr
vr = v;       //assigns a new value to n and vr

float64 n2 = 10000;
value_ref vi(std::ref(n2));

vr = vi;      //rebinds the vr to n2
\end{cppcode}
In the first two cases a new value is assigned to \cpp{vr} while in the latter
case the assignment between two instances of \cpp{value\_ref} causes a rebind of
\cpp{vr} to the variable $n2$. This may cause some trouble. If only the value of
a reference should be assigned we need to use the \cpp{static\_cast} function
and replace the last line with
\begin{cppcode}
vr = static_cast<value>(vi);
\end{cppcode}
By casting to \cpp{value}  we do not have to care about the particular data type
held by \cpp{vi}. However, one must take care that the types do match, otherwise
a \cpp{type\_error} exception will be thrown.

%%%============================================================================
\section{Type erasures for arrays}

As \libpnicore\ provides a virtually indefinite number of array types via its
\cpp{mdarray} template the \cpp{array} type erasure is maybe one of the most
important ones. Like the \cpp{value} type erasure it will take over full
ownership of the array stored in it.

A good introduction into the \cpp{array} type erasure is this particular version
of the array inquiry  example from the previous chapter on arrays. 
\inputminted[linenos,
             fontsize=\small,
             firstnumber=25,
             firstline=25,
             lastline=62,
             frame=lines,
             label=examples/type\_erasure3.cpp]
{cpp}{../examples/type_erasure3.cpp}
In the previous version, where \cpp{show\_info} was a template function a new
version of \cpp{show\_info} would have been created for each of the three array
types used in this example. By using the type erasure only a single version of
\cpp{show\_info} is required which reduces the total code size of the binary.

The current implementation of \cpp{array} is rather limited in comparison 
to the \cpp{mdarray} template. Multidimensional access is not provided and only
forward iteration is implemented. In addition there is now \cpp{array\_ref} 
type erasure which only keeps a reference to an instance of \cpp{mdarray}. 

The iterators themselves have a subtle speciality. They do not provide a
\cpp{->} operator. This has a rather simple reason. While all other interators
return a pointer to a particular data element in a container the \cpp{array}
iterators cannot do this (they do no hold any type information). Instead they
return an instance of \cpp{value} for constant or \cpp{value\_ref} for
read/write iterators. In order to keep the semantics of the \cpp{->} operator we
would have to return \cpp{*value} or \cpp{*value\_ref} from the \cpp{->}
operator. However, this is not possible as these objects are just temporaries
and would be destroyed once the operator function has returned. 
However, this is only a small inconvenience as it has no influence on the 
STL compliance of the iterator. 
One can still use the \cpp{foreach} construction
\begin{cppcode}
array a(...);

for(auto x: a)
    std::cout<<s<<std::endl;
\end{cppcode}
and all STL algorithms with a \cpp{array} type erasure.


%%%============================================================================
\section{An example: reading tabular ASCII data}

In this final section a typical use-case for a type erasure will be discussed. 
One problem that regularly pops up is to read tabular ASCII data. 
For this example a very simple file format has been used. The file
\cpp{record.dat}
has the following content
\inputminted[fontsize=\small,
             frame=lines,
             label=examples/record.dat]
{text}{../examples/record.dat}
While the elements of the first two columns are integer and float respectively,
the third column holds complex numbers. The task is simple: read the values from
the file without losing information. This means that we do not want to truncate
values (for instance float to integer) or do inappropriate type conversions (for
instance convert everything to the complex type) which may add rounding errors. 

There are several ways how to approach this problem. The most straight forward
one would be to create a \cpp{struct} with an integer, a float, and a complex
element. However, this approach is rather static. If a column will be added or
removed or only the order of the columns is changed we have to alter the code. 

In this example a different path has been taken. Each individual line is
represented by a record type which consists of a vector whose elements are
instances of the \cpp{value} type erasure.   
\inputminted[linenos,
             fontsize=\small,
             firstnumber=26,
             firstline=26,
             lastline=40,
             frame=lines,
             label=examples/type\_erasure\_record.cpp
             ]
{cpp}{../examples/type_erasure_record.cpp}
The entire table is again a vector with \cpp{record\_type} as element type.
In addition we have defined a special type to store complex numbers
(\cpp{complex\_type}).

\subsection{Defining the parsers}

One of the key elements for this example is to use the \cpp{boost::spirit}
parser framework. We define three parsers
\begin{enumerate}
\item one for the \cpp{complex\_type}
\item one for a value which can parser integer, double, and complex numbers
\item and one for the entire record.
\end{enumerate}
The \cpp{boost::spirit} framwork is indeed rather complex and requires a deep
understanding of some of the additional boost libraries like \cpp{fusion} and
\cpp{phoenix}. However, as we will see, it is worth to become familiar with them
as will be shown here.
\todo{Add a reference for the boost documentation here}

In this next snippet the definition of the complex number parser is shown. 
\inputminted[linenos,
             fontsize=\small,
             firstnumber=45,
             firstline=45,
             lastline=61,
             frame=lines,
             label=examples/type\_erasure\_record.cpp
             ]
{cpp}{../examples/type_erasure_record.cpp}
We assume complex numbers to be stored as tuples of the form \cpp{(real
part,imaginary part)}. As we can see in the above example the complex type is
assembled from the two double values matched in the rule. The next parser
required is the value parser. This parser matches either an integer, a double,
or a complex value. It is a good example how to reuse already existing 
parser in \cpp{boost::spirit}. 
\inputminted[linenos,
             fontsize=\small,
             firstnumber=66,
             firstline=66,
             lastline=89,
             frame=lines,
             label=examples/type\_erasure\_record.cpp
             ]
{cpp}{../examples/type_erasure_record.cpp}
Finally we need a parser for the entire record. This is rather simple as
\cpp{boost::spirit} provides a special syntax for parsers who store their
results in containers.
\inputminted[linenos,
             fontsize=\small,
             firstnumber=94,
             firstline=94,
             lastline=107,
             frame=lines,
             label=examples/type\_erasure\_record.cpp
             ]
{cpp}{../examples/type_erasure_record.cpp}

\subsection{The main program}

The main program is rather simple 
\inputminted[linenos,
             fontsize=\small,
             firstnumber=162,
             firstline=162,
             lastline=175,
             frame=lines,
             label=examples/type\_erasure\_record.cpp
             ]
{cpp}{../examples/type_erasure_record.cpp}
Not all the code will be explained as it is only those parts which are of
interest for the \cpp{value} type erasure.
The program can be divided into two parts:
\begin{enumerate}
\item reading the data (in line $166$) 
\item and writing it back to standard output (in line $172$)
\end{enumerate}
As the latter one is rather trivial we will only consider the reading part in
this document. The output of the main function is 
\begin{minted}[fontsize=\small,frame=lines]{bash}
INT32
FLOAT64
COMPLEX32
11      -123.23 (-1,0.23)
13      -12.343 (12.23,-0.2)
16      134.12  (1.23,-12.23)
\end{minted}

\subsection{The reading sequence}

The entry point for the read sequence is the \cpp{read\_table} function.
\inputminted[linenos,
             fontsize=\small,
             firstnumber=128,
             firstline=128,
             lastline=141,
             frame=lines,
             label=examples/type\_erasure\_record.cpp
             ]
{cpp}{../examples/type_erasure_record.cpp}
The logic of this function is rather straight forward. Individual lines are
written from the input stream until \cpp{EOF} and passed on to the
\cpp{parse\_record} function which returns an instance of \cpp{record\_type}. 
Each record is appended to the table. 

The \cpp{parse\_record} function is where all the magic happens
\inputminted[linenos,
             fontsize=\small,
             firstnumber=112,
             firstline=112,
             lastline=123,
             frame=lines,
             label=examples/type\_erasure\_record.cpp
             ]
{cpp}{../examples/type_erasure_record.cpp}
The definition of this function pretty much demonstrates the power of the
\cpp{boost::spirit} library. All the nasty parsing work is done by the code 
provided by \cpp{boost::spirit}. The only thing left to do is provide iterators
to the beginning and end of the line.


