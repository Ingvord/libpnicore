%%%documentation on arrays

C++ has no multidimensional array type (MDA) in its standard library. 
However, MDAs are crucial for the developmemt of scientific applications.
One of the reasons for the continuing success of languages like Fortran or Python
is their excellent support for MDAs\footnote{For Python arrays are introduced by
the {\tt numpy} package.}. The lack of an MDA type in C++
was indeed the spark that initiated the developement of \libpnicore.  Before
discussing \libpnicore s array facilities some terminology should be defined: 
%%%----------------------------------------------------------------------------
\begin{center}
\begin{tabular}{m{0.2\linewidth}p{0.7\linewidth}}
    element type (ET) &  referes to the data type of the individual elements
    stored in an MDA. For MDAs this will typically be a numeric type like an
    integer or a floating point number.\\

    rank $r$ & denotes the number of dimensions of an MDA \\

    shape $\mathbf{s}$ & is a vector of dimension $r$ whose elements are the
    number of elements along each dimension. The elements of $\mathbf{s}$ are
    denoted as $s_i$ with $i=0,\hdots,r-1$ \\
\end{tabular}
\end{center}
%%%----------------------------------------------------------------------------
The hart of \libpnicore's MDA support is the {\tt mdarray} template. 
{\tt mdarray} is extremely powerfull. Thus, using {\tt mdarray} directly to
define array types is not for the faint harted.  To simplify
the usage of multidimensional arrays the library provides three templates
derived form {\tt mdarray} which are easy to use.  
%%%----------------------------------------------------------------------------
\begin{center}
\begin{tabular}{m{0.2\linewidth}p{0.7\linewidth}}
\sdarray &  
a static arrays whose shape, rank, and element type are fixed at compile time.
\\
\farray &
element type and rank are fixed at compile time but the shape can be changed at
runtime. \\
\darray & 
a fully dynamic array type where only the element type must be known at compile
time. The rank as well as the shape can be altered at runtime\\
\end{tabular}
\end{center}
%%%----------------------------------------------------------------------------
These types are all defined in {\tt pni/core/arrays.hpp}.
In addition to this two basic templates there are several utility classes and
templates like
%%%----------------------------------------------------------------------------
\begin{center}
\begin{tabular}{m{0.15\linewidth}p{0.7\linewidth}}
\arrayview &  a template providing a particular view on an array (see
Sec.~\ref{sec:array:array_slicing}) \\
\arrayerasure & a type erasure that can be used with any instance of an array
template (see Chapter~\ref{chapter:type_erasure})
\end{tabular}
\end{center}
%%%----------------------------------------------------------------------------

All array types derived from {\tt mdarray} provide the following features
\begin{enumerate}
\item unary and binary arithmetics if the element type is a numeric type.
\item slicing to extract only a part of a large array
\item simple access to data elements using variadic operators.
\item all array types are full STL compliant containers and thus can be used
along with STL algorithms.
\end{enumerate}

\section{Array construction and inquery}
    
Constructing arrays is rather simple by means of the {\tt ::create} function
provided by the array templates. The next example shows how to create arrays 
using this static function

\inputminted[fontsize=\small,linenos,firstline=24,frame=lines]{cpp}
{../examples/array_create.cpp}
In line $12$ a concrete array type is defined from the {\tt dynamic\_array}
utility template.
The {\tt::create} function comes in three flavors as shown in the previous
example
\begin{description}
\item[line 17] it takes the shape of the array as a container and constructs the
array from this. In this case the storage container is allocated internally. 
\item[line 20] the storage container is passed along with the shape.
\item[line 24] here the shape and the container are passed as initializer lists
- this can make the syntax more readable in some cases.
\end{description}
After an array has been created we may want to retrieve some of its basic
properties. In the next example we do exactly this 

\inputminted[fontsize=\small,linenos,firstline=24,frame=lines]{cpp}
{../examples/array_inquery.cpp}
The important part is the implementation of the {\tt show\_info} function
template starting at line $14$. The function template {\tt type\_id} is used in
line $17$ to retrieve the type ID of the arrays element type. {\tt rank} in line
$18$ returns the number of dimension and {\tt size} in line $23$ the total
number of elements stored in the array. 
The {\tt shape} template function in line $20$ returns the number of elements
along each dimension stored in a user provided container type.

\section{Linear access to data}
As already mentioned in the first section of this chapter, the array types
provided by \libpnicore\ are fully STL compliant containers. They provided all
the iterators required by the STL. 
Before we have a look on STL lets first investigate how to simply access data
elements in an array

\inputminted[fontsize=\small,linenos,firstline=24,frame=lines]{cpp}
{../examples/array_linear_access.cpp}
For all array types the new C++ {\em for-each} construction can be used as shown
in lines $24$ and $34$. Unchecked access (no index bounds are checked) is
provided via the {\tt []} operator as demonstrated in line $27$. Finally, in
cases where the index should be checked use the {\tt at()} method like in lines 
$30$ and $31$.
Some of the operations in this example can be done much more efficient with STL
algorithms as demonstrated in the next example

\inputminted[fontsize=\small,linenos,firstline=24,frame=lines]{cpp}
{../examples/array_stl.cpp}
In line $19$ {\tt std::fill} is used to initialize the array to $0$ and 
{\tt std::generate} in line $25$ fills it with random numbers using a lambda
expression . The rest of the example should be trivial (if not, please lookup a
good C++ STL reference).

\section{Multidimensional access}

Though being an important feature, linear access to multidimensional arrays is
not always useful. In particular the last example where we pretended to work on
image data implementing algorithms would be rather tedious if we would have had
only linear access. It is natural for such objects to think in pixel coordinates
$(i,j)$ rather than the linear offset in memory. 
\libpnicore\ provides easy multidimensional access to the data stored in an
array. The next example shows how to use this feature to work only on a small
region of the image data as defined in the last example
\inputminted[fontsize=\small,linenos,firstline=24,frame=lines]{cpp}
{../examples/array_multiindex.cpp}
The interesting part here are lines $36$ and $37$. You can pass the
multidimensional indexes either as a variadic argument list to the  {\tt ()}
operator of the array type (as in line $36$) or you can use a container like 
in line $37$. The former approach might look a bit more familiar, however, in
some cases when decisions have to made at runtime the container approach might
fits better.

\section{Array views and slicing}

In the previous example multiindex access was used to do work on only a small
part of the image data. \libpnicore\ provides view types for arrays which would
make these operations easier:
\inputminted[fontsize=\small,linenos,firstline=24,frame=lines]{cpp}
{../examples/array_view.cpp}

\inputminted[fontsize=\small,linenos,firstline=24,frame=lines]{cpp}
{../examples/array_view_container.cpp}

\section{Arithmetic expressions}

