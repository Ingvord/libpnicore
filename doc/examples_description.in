/*! \page examples_description Examples

Sometimes it is easier to get an idea of how to use a library by watching some
example code rather than reading through hundreds of pages of design
descriptions. This page explains the code examples shipped with the
distribution. 

- \subpage examples_buffers 
- \subpage examples_io
*/

/*! \page examples_buffers Using Buffers

The \c Buffer<T,Allocator> and \c RefBuffer<T,Allocator>  templates are simple
but powerful tools to guard memory. Their major aim is to avoid memory leaks. A
buffer object allocates memory and frees it at least when it is destroyed (when
its destructor is called). Thus, by using the Buffer templates, creating
exception save applications should be quite easy. Buffers use allocators to
allocate and free memory. However, allocators are beyond the scope of this
section and will not be treated here. 

\section buffer_examples Using the Buffer<T,Allocator> template

In the first example we consider ways and methods how to create instances of a
\c Buffer<T,Allocator> template and how to get some information out of it.
\includelineno example_buffer1.cpp


There are basically three methods how to access data stored in a \c Buffer<T>
template: 

- via the at() member method
- the [] operator
- or via the raw pointer

Each of these methods has its own advantages and disadvantages as will be shown
in the next example.
\includelineno example_buffer2.cpp

Using the [] operator to access element in the buffer makes your code look
pretty much like plain old C. This operator does not do any index
checking. If the index passed exceeds the size of the allocated memory you will
most probably experience a segmentation fault. However, as it is implemented as
inline the [] operator is pretty efficient and should produce virtually no
overheard over accessing the data via the raw pointer. 
Alternatively one can use the at() method provided. Unlike the [] operator it
performs an index check and throws an IndexError exception if the index exceeds
the size of the allocate memory. 
The last method to access the content of the buffer object is to use the ptr()
or void_ptr() methods which return a raw pointer to the allocated memory. 
This sounds like a violation of all rules about object oriented programming.
However, keep the intention of the template in mind: to guard memory, and hide
memory allocation. 
It is and was never intended to hide the data in memory itself. Besides,
whenever you want to work with third party libraries which rely on plain raw
pointers you somehow need access to this. 


\section refbuffer_examples Using the RefBuffer<T,Allocator> template

While \c Buffer<T,Allocator> is used to guard memory (managed by the \c
Buffer<T,Allocator> template by itself)  and provide an interface
from \c libpniutils to other 3rd party code relying on raw pointers, the
intention of the \c RefBuffer<T,Allocator> template is exactly the other way
around. It is used to use memory managed by 3rd-party code and provided as raw
pointer. Thus, the \c RefBuffer<T,Allocator> does no memory management at all. 
It can be considered as a kind of decorator for raw pointers which can be 
used to make this memory available to classes and functions \c libpniutils 
provides. Obviously the \c Allocator type is not of importance for this 
template as it does no memory management at all.

\includelineno example_buffer3.cpp
*/

/*! \page examples_io Using the IO classes

\includelineno cbf_reader.cpp
\includelineno tif_reader.cpp
\includelineno fio_reader.cpp

*/

*/

